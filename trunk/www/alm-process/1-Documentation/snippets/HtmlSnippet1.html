<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><h2><a name="Purpose"></a>Purpose </h2><p>The rearranger plugin </p><ul><li>rearranges (reorders) <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#OrderAnchor">class and class member declarations</a> according to a user-specified order and/or method call hierarchy; </li><li>generates <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#SeparatorCommentAnchor">section-marking comments</a>; </li><li>provides several controls for <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#SpacingAnchor">spacing</a> within and between methods and classes; and </li><li>permits the user to <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#LiveRearranger">manually rearrange items</a>. </li></ul><p>&nbsp;</p><h2><a name="Description"></a>Description </h2><p>The plugin performs two basic automatic rearrangement tasks: </p><ul><li>reordering the outer classes in a Java file, and </li><li>reordering the fields, methods, and inner classes within an outer class. </li></ul><p>Rearrangement is based on configuration supplied by the user, on the relationship between methods based on method calls, or both. </p><p>A default configuration is supplied and is loaded the first time the plugin is seen. If the configuration is empty, no rearrangement takes place. </p><p>The user may create a list of entries, specifying various attributes of the fields, methods, and classes. These attributes include all the standard Java modifiers (public, private, protected, final, static, etc.) as well as some other criteria (e.g., method is constructor, method is getter/setter, method is overloaded, and so on). </p><p>The list may also contain comment entries. Comments may be conditionally inserted before or after reordered groups. </p><p>Extracted (related) methods may be grouped with their callers. An extracted method is one which is called by another method. </p><p>Getters and setters may be kept adjacent, as well as overloaded methods (including constructors). </p><p>Finally, the number of blank lines appearing before or after certain braces may be specified. </p><p>&nbsp;</p><h2><a name="Using"></a>Using </h2>The Rearranger works with <font color="#810081"><a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a></font>&nbsp;versions 4.0 and above. (If you are on a non-Windows platform, ensure that IDEA is running with Java 1.5 or later.) <p>Use IDEA's Plugin Manager to install the Rearranger plugin. &nbsp;Installing any plug-in with <a href="http://www.jetbrains.com/idea/">IDEA</a>, including the Rearranger, is a snap.&nbsp; You don't have to download or build anything. In <a href="http://www.jetbrains.com/idea/">IDEA</a>, click File | Settings | IDE Setting | Plug-ins.&nbsp; You can then view the plug-ins installed already and what is available. &nbsp;Right click &quot;Rearranger&quot;, and select install. &nbsp;(Selecting and hitting OK does nothing). </p><p>To <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#ConfigurationAnchor">configure</a>, go to &quot;Settings...IDE Settings...Rearranger&quot; configuration dialog. </p><p>To automatically rearrange a file, first edit the desired Java file, then choose Edit...Rearranger (or Ctrl-Alt-Shift-R, the default shortcut). (Alternatively, if the Reformat plugin is installed, the Rearranger will run automatically after Reformat finishes.) </p><p>If the <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#ConfirmAnchor">Preview Rearrangement</a> option is checked, a dialog displaying a tree of the proposed rearrangement appears, which the user can accept or reject. </p><p>To <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#LiveRearranger">manually rearrange</a> a file, edit the desired Java file, then choose Edit...Live Rearranger (or Ctrl-comma, the default shortcut). </p><p>A description of the plugin's operation can be found <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#OperationAnchor">here</a>. </p><p><a name="ConfigurationAnchor"></a></p><h2><a name="Configuration"></a>Configuration </h2>There are six basic areas of configuration: <ul><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#OrderAnchor">specifying outer class order</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#OrderAnchor">specifying order of class contents (members)</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#RelatedMethodAnchor">specifying how related methods are to be organized</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#SpacingAnchor">specifying spacing requirements</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#GeneralAnchor">choosing miscellaneous options</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#ConfigurationControlAnchor">saving, restoring, or loading default configuration</a> </li></ul><p><a name="OrderAnchor"></a></p><h3><a name="Class_Member_Order_Outer_Class_O"></a>Class Member Order, Outer Class Order </h3>To control the order of outer classes or class contents, you create a list of rules which describe class or class member attributes. Choose one (or both) of the first two configuration tabs: <ul><li>&quot;Class Member Order&quot; controls the order of fields, methods and inner classes within a class; </li><li>&quot;Outer Class Order&quot; controls the order of top level classes in the Java file. </li></ul><p>This is a sample of what the &quot;Class Member Order&quot; pane might look like: </p><p><br /><img alt="rearranger44cmo2.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147364/rearranger44cmo2.PNG" border="0" /> </p><p>On each of the first two tabs, you can add, edit, duplicate, or remove rules, or move them up and down in the list. </p><h4><a name="Rule_Types"></a>Rule Types </h4>All items (outer classes, fields, methods, and inner classes) may be selected on the basis of their type, and presence or absence of other attributes such as protection level, final, or static attributes. Only fields match a rule whose type is &quot;field,&quot; and so on. <p>All items may be selected by matching their names to a regular expression pattern. </p><p>If no protection level is specified in a rule, then protection level is ignored when matching. </p><p>Additional attributes exist where appropriate for individual rule types. </p><p>The rule types for &quot;Class Member Order&quot; rules are: </p><ul><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#FieldAnchor">Field</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#MethodAnchor">Method</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#InterfaceMethodAnchor">Interface Methods</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#InnerClassAnchor">Inner Class</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#SeparatorCommentAnchor">Separator Comment</a> </li></ul><p>The rule types for &quot;Outer Class Order&quot; rules are: </p><ul><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#InnerClassAnchor">Class</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#SeparatorCommentAnchor">Separator Comment</a> </li></ul><p>In all cases except comments, a number of attributes may be specified. Classes or class members are then rearranged in order of the rules whose attributes they match. </p><p>&nbsp;</p><h4><a name="Rule_Sequence_and_Rule_Priority"></a>Rule Sequence and Rule Priority </h4>The order in which rules are specified (sequence order) dictates the order in which rearranged items will appear in the resulting file. Rule priority controls the order in which rule items are matched. By default, all rules have a priority of 1 (the lowest). The priority can be changed by double clicking on the &quot;Priority&quot; field of the desired row. Clicking on the &quot;Seq&quot; (sequence) or &quot;Pri&quot; (priority) column headers will sort the table; sequence numbers are sorted in ascending order, priority in descending order. This order can be reversed by shift-clicking on the column header. <p>An example of the usefulness of rule priority is when a method is matched by name. Suppose that you want all methods, then all fields, then any methods whose name is &quot;main&quot;. Without rule priority, you would have to specify the following rules: </p><p>&nbsp;</p><ol><li>All methods whose name does not match &quot;main&quot; </li><li>All fields </li><li>All methods whose name matches &quot;main&quot; </li></ol><p>Assigning a higher priority to rule 3 would eliminate the need to specify the &quot;name does not match&quot; clause in rule 1. </p><p><a name="FieldAnchor"></a></p><h4><a name="Field_Rule"></a>Field Rule </h4>The &quot;Field&quot; rule arranges fields with matching attributes together. <p>The field attributes dialog is as follows: </p><p><br /><img width="672" height="794" alt="rearrangerField44.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147369/rearrangerField44.PNG" border="0" /> </p><p>Fields may be selected on the basis of protection level, static, final, transient, and volatile attributes. Fields may be selected if they are initialized to an instance of an anonymous class. Fields may also be selected on the basis of matching their type to a regular expression. </p><p>If any sort options are checked, fields matching the rule will be rearranged according to the options. Otherwise, fields retain their original relative order. </p><p>Fields may be alphabetized by modifiers (e.g. &quot;public final&quot;), by type, and/or by name, grouping fields of the same type together. The type and name alphabetization can be case insensitive, so that (for example) primitive types like &quot;int&quot; would appear between &quot;Boolean&quot; and &quot;String&quot;. </p><p><a name="MethodAnchor"></a></p><h4><a name="Method_Rule"></a>Method Rule </h4>The method attributes dialog is as follows: <p><br /><img width="672" height="794" alt="rearranger44method.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147368/rearranger44method.PNG" border="0" /> </p><p>Methods may be selected by their category (constructor, getter/setter, canonical, or other). A canonical method is one that is inherited from java.lang.Object. </p><p>If no method category is specified, the method category criterion is not applied. </p><p>The implemented/-ing and overridden/-ing criteria are defined as follows: </p><ul><li>&quot;implementing&quot; means the method implements an abstract or interface method </li><li>&quot;implemented&quot; means the abstract or interface method is implemented elsewhere </li><li>&quot;overriding&quot; means the method overrides a concrete supermethod </li><li>&quot;overridden&quot; means the concrete method is overridden elsewhere </li></ul><p>Methods may be selected based on whether their return type matches a regular expression or not. </p><p>Methods may be selected based on a minimum and/or maximum number of parameters. </p><p>If &quot;Exclude from extracted method processing&quot; is checked, methods matching this method rule will be moved, but their <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#RelatedMethodAnchor">related (extracted) methods</a> won't. This permits those (otherwise extracted) methods to match rules of their own. For example, checking this box on a rule &quot;All constructor methods&quot; would arrange all constructors together, but would not arrange any called methods with them. </p><p>Methods may be sorted by modifiers (e.g., &quot;synchronized&quot;), by return type, or by name. </p><p>&nbsp;</p><h5><a name="Getter_Setter_definition_for_a_m"></a>Getter/Setter definition for a method </h5>When a method rule is created, the default definition specified in <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#GeneralAnchor">General Options pane</a> for getter/setter is copied. This definition may be changed per rule by clicking on the &quot;getter/setter&quot; button in the method type selection box. Doing so brings up the following dialog: <p><br /><img width="455" height="238" alt="RearrangerGSDef17.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147374/RearrangerGSDef17.png" border="0" /> </p><p>Refer to <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#GeneralAnchor">General Options</a> for more information. </p><p><a name="InterfaceMethodAnchor"></a></p><h4><a name="Interface_Methods_Rule"></a>Interface Methods Rule </h4>An interface methods rule causes methods which implement one or more interfaces to be grouped together. Unless otherwise specified (by name matching criterion), all interfaces match this rule, and all methods implementing an interface method will be moved. Methods belonging to one interface are never intermixed with those of another. <p>The interface methods attributes dialog is as follows: </p><p><br /><img width="672" height="794" alt="rearranger44Interface.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147367/rearranger44Interface.PNG" border="0" /> </p><p>If &quot;Alphabetize Interfaces&quot; is checked, then interface method groups are arranged in alphabetical order based on the interface name. Otherwise, interfaces are arranged in the order their first implementing method is encountered. </p><p>Leading and trailing comments may be specified for each interface method group. These comments serve to delimit methods of a particular interface. Any occurrence of &quot;%IF%&quot; in the comment will be replaced by the interface name. See <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#GlobalCommentPatternAnchor">Global Comment Pattern</a> for related information. </p><p><a name="InnerClassAnchor"></a></p><h4><a name="Class_Inner_Class_Rule"></a>Class / Inner Class Rule </h4>The inner class attribute dialog is as follows (the outer class dialog is similar): <p><br /><img width="672" height="794" alt="rearranger44InnerClass.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147366/rearranger44InnerClass.PNG" border="0" /> </p><p>If &quot;enum&quot; is checked, then only classes which are enumerations (keyword &quot;enum&quot;) will match the rule. </p><p>Classes may be sorted by modifiers (e.g. &quot;public abstract&quot;), type (class or enum), and/or name. <a name="SeparatorCommentAnchor"></a></p><h4><a name="Separator_Comment_Rule"></a>Separator Comment Rule </h4>The comment attribute dialog is as follows: <p><br /><img width="423" height="607" alt="rearranger39comment.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147360/rearranger39comment.PNG" border="0" /> </p><p>Before rearranging, the file is scanned for any existing comments that match the comments or the <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#GlobalCommentPatternAnchor">global comment pattern</a> specified by the user; if any are found, they are removed (on the assumption that they were generated by the plugin during a previous rearrangement). Adjacent blank lines are also removed, so that the final result will contain only those blank lines specified in the separator comment definition. </p><p>Then, as rules are executed, comments are inserted as they are encountered in the list if certain criteria are met. A comment may be emitted: </p><ul><li>unconditionally </li><li>only if items match any or all of the preceding rules </li><li>only if items match any or all of the subsequent rules </li><li>based on both (previous and subsequent) conditions </li></ul><p>For example, if your Class Member Order rules are defined as follows: </p><p>&nbsp;</p><ol><li>Comment (// FIELDS BEGIN HERE) when any of subsequent 2 rules are matched </li><li>Comment (// PRIVATE FIELDS BEGIN HERE) when subsequent rule is matched </li><li><strong>private fields</strong> </li><li>Comment (// PRIVATE FIELDS END HERE) when preceding rule is matched </li><li>Comment (// STATIC FIELDS BEGIN HERE) when subsequent rule is matched </li><li><strong>static fields</strong> </li><li>Comment (// STATIC FIELDS END HERE) when preceding rule is matched </li><li>Comment (// FIELDS END HERE) when any of preceding 2 rules are matched </li></ol><p>then the &quot;PRIVATE FIELDS&quot; comments will only appear if one or more private fields were found; likewise, the &quot;STATIC FIELDS&quot; comments will only appear if one or more static fields were found. The &quot;FIELDS BEGIN/END HERE&quot; comments will only appear if at least one private or static field was found. </p><p>Blank lines may appear before and/or after the comment; simply insert them in the comment definition. </p><p><a name="FillStringAnchor"></a>A &quot;fill string&quot; capability allows comments to be dynamically adjusted to a specified width. By default, the width is the project's right margin but may be overridden. All occurrences of &quot;%FS%&quot; in each line of the comment are replaced by an equal number of characters from the fill string, causing the comment to expand to the desired width. Comments may therefore be left or right justified, or centered. For example, </p><pre>// Left-Justified Comment %FS% // %FS% Right-Justified Comment // %FS% Centered Comment %FS% </pre><p><a name="RelatedMethodAnchor"></a></p><h3><a name="Related_Extracted_Methods"></a>Related (Extracted) Methods </h3>The &quot;Extracted Methods&quot; tab controls the grouping and ordering of calling and called methods. It will arrange called methods underneath calling methods in a variety of ways. Comments can be generated to delineate top level groups, every method, every level, or every family of methods. <p>The extracted method dialog contains two panes: </p><ul><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#ExtractedMethodGroupingAnchor">Grouping</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#ExtractedMethodCommentAnchor">Comment Generation</a> </li></ul><p><a name="ExtractedMethodGroupingAnchor"></a></p><h4><a name="Extracted_Method_Grouping"></a>Extracted Method Grouping </h4>The first pane controls grouping, as follows: <p><br /><img alt="Rearranger13ExtractedMethodArrangement.PNG" src="https://www.dev.java.net/files/documents/10436/147370/Rearranger13ExtractedMethodArrangement.png" border="0" /> </p><p>The first checkbox, &quot;Move extracted methods,&quot; controls whether or not extracted methods will be moved under their callers. If checked, all other controls on the dialog are enabled. If unchecked, all calling-based relationships between methods are ignored. (Overloaded and related getter/setter methods are handled separately; these are name-based or function-based relationships.) </p><p>If called by more than one method, an extracted method may be placed under the first or last caller by choosing &quot;below first usage&quot; or &quot;below last usage.&quot; </p><p>When nested calls are made, so that an extracted method is a caller of other extracted methods, the extracted methods may be arranged in depth-first or breadth-first order. </p><p>The order of the extracted methods under a parent may be: </p><ul><li>order of invocation (usage order of appearance) </li><li>original order (relative to position before rearrangement) </li><li>alphabetical </li></ul><p>All private methods are considered extracted methods. No getters or setters are considered extracted methods. However, there may be ambiguity about remaining (non-private, non-getter/setter) methods. A rule exists to control whether to consider these methods as extracted methods: </p><ul><li>never </li><li>only if called by exactly one other method (which could invoke it multiple times) </li><li>when it has one or more callers in the class. </li></ul><p><a name="ExtractedMethodCommentAnchor"></a></p><h4><a name="Extracted_Method_Comment_Generat"></a>Extracted Method Comment Generation </h4>The other pane specifies where comments should be generated, as follows: <p><br /><img alt="rearranger39extractedmethodcomments.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147361/rearranger39extractedmethodcomments.PNG" border="0" /> </p><p>Comments may be placed before and/or after groups of extracted methods. The first box specifies where comments should be placed: </p><ul><li>Top Level: comments will be placed before the first (top-level) calling method, and after the last extracted method in the tree. </li><li>Each Method: comments will be generated before and after each method in the tree. </li><li>Each Level: comments will be generated before and after each level change recursively; i.e., in a breadth-first traversal, level 1 ends after level 2 ends, not before. </li><li>Each Family: comments will be generated to group all siblings (except before the first) who have no children. Siblings with children start a new &quot;family.&quot; </li></ul><p>These comments may also utilize the <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#FillStringAnchor">fill string</a> feature. </p><p><a name="GeneralAnchor"></a></p><h3><a name="General_Options"></a>General Options </h3>The &quot;General&quot; tab allows you to specify several options: <ul><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#GetterSetterAnchor">Keep getters/setters together</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#GSWithPropertyAnchor">Keep getters/setters with property</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#OverloadedAnchor">Keep overloaded methods together</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#ConfirmAnchor">Confirm before rearranging</a> </li><li><a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#RearrInnerClassAnchor">Rearrange contents of inner classes</a> </li><li>default criteria for determining if a [[#GetterSetterFormulaAnchor][method is a getter or setter]; </li><li>that a global <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#GlobalCommentPatternAnchor">comment pattern</a> be applied when removing comments before rearranging. </li></ul><p><br /><img alt="Rearranger38General.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147358/Rearranger38General.PNG" border="0" /> </p><p>A detailed description of each option follows. </p><p><a name="GetterSetterAnchor"></a></p><h4><a name="Keep_Getters_Setters_Together"></a>Keep Getters/Setters Together </h4>Setting this option will cause setters to appear immediately below getters, wherever the rearrangement may place them. If sorted by name, the property name will be used (not the getter method name). <p><a name="GSWithPropertyAnchor"></a></p><h4><a name="Keep_Getters_Setters_With_Proper"></a>Keep Getters/Setters With Property </h4>Setting this option causes getters and setters to appear immediately below their associated property (field) declaration. <p>This option is only enabled if Keep Getters/Setters Together is enabled. </p><p><a name="OverloadedAnchor"></a></p><h4><a name="Keep_Overloaded_Methods_Together"></a>Keep Overloaded Methods Together </h4>Setting this option groups overloaded methods (those with identical function names, but different parameter types or number of parameters) together. These overloaded methods, including constructors, may be sorted by number of parameters (ascending or descending), or kept in original order. <p><a name="ConfirmAnchor"></a></p><h4><a name="Confirm_Before_Rearranging"></a>Confirm Before Rearranging </h4>Setting this option will cause a popup (similar to the Ctrl-F12 file structure popup) to appear before rearrangement takes place. This popup contains a tree showing the order and hierarchical arrangement of classes and class members, including the nesting order of extracted methods. OK this to proceed with rearrangement, or Cancel to stop. <p>The following illustration shows the confirmation dialog, configured to display all fields, parameter types and names in method declarations, and all rules. </p><p><br /><img width="737" height="805" alt="Rearranger26confirmyyyyyyn.png" src="https://rearranger.dev.java.net/files/documents/10436/147372/Rearranger26confirmyyyyyyn.png" border="0" /> </p><p>&nbsp;</p><p>This can aid in debugging the rearranger configuration, as it shows exactly what rule every item matches. </p><p>The dialog can be significantly simplified by restricting the rules to only those with matches, or by not displaying rules at all: </p><p><br /><img width="730" height="412" alt="Rearranger26confirmyyyyynn.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147371/Rearranger26confirmyyyyynn.png" border="0" /> </p><p>The buttons to control the format and content of the tree are: </p><p><br /><img width="28" height="28" alt="ShowParamTypes.png" src="https://rearranger.dev.java.net/files/documents/10436/147376/ShowParamTypes.png" border="0" /> controls whether or not parameter types are displayed in method declarations. <br /><img width="28" height="28" alt="ShowParamNames.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147380/ShowParamNames.png" border="0" /> controls whether or not parameter names are displayed in method declarations. <br /><img width="28" height="28" alt="ShowFields.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147378/ShowFields.png" border="0" /> controls whether or not fields are displayed in the proposed rearrangement tree. <br /><img width="28" height="28" alt="ShowTypeAfterMethod.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147382/ShowTypeAfterMethod.png" border="0" /> controls whether the method type appears after or before the method name. <br /><img width="28" height="28" alt="Showcomments.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147377/ShowComments.png" border="0" /> controls whether or not comments (and comment rules, if Show Rules is selected) will appear in the proposed rearrangement tree. <br /><img width="28" height="28" alt="Showrules.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147381/ShowRules.png" border="0" /> controls whether or not rules will appear within the rearrangement tree. If selected, all rules appear in the tree (in italicized text) and all matches to those rules appear beneath the rule's node. Otherwise, only the classes and class members appear. <br /><img width="28" height="28" alt="Showmatchedrules.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147379/ShowMatchedRules.png" border="0" /> Restricts the display to only those rules with matches. This eliminates clutter in the display. </p><p><a name="RearrInnerClassAnchor"></a></p><h4><a name="Rearrange_Contents_of_Inner_Clas"></a>Rearrange Contents of Inner Classes </h4>If checked, contents of inner classes will be rearranged recursively. If not, contents of inner classes are copied intact to the resulting file. <p><a name="GetterSetterFormulaAnchor"></a></p><h4><a name="Default_Getter_Setter_Definition"></a>Default Getter/Setter Definition </h4>This definition specifies the default criteria for determining if a given method is a getter or setter. Criteria are based on the method name and body. A getter method name must begin with a valid prefix (&quot;get&quot;, &quot;is&quot;, &quot;has&quot;); it may also be required to have a field name which is returned by the method. A getter body may be ignored, required to have a return statement, or required to have a return statement followed by the field name specified in the method name. A setter method name must begin with &quot;set&quot;; it may also be required to have a field name which is assigned by the method. A setter body may be ignored or be required to have one assignment statement which assigns the parameter value to the field name. <p>This definition will be copied by any method rules created afterward. A method rule may override the definition. If a method does not match any rule, the default definition is used to determine if it is a getter or setter. </p><p><a name="GlobalCommentPatternAnchor"></a></p><h4><a name="Global_Comment_Pattern"></a>Global Comment Pattern </h4>The comment pattern is a regular expression to which all your fixed comments should conform. The Rearranger will remove any comments matching this pattern before it does the rearrangement. This prevents duplicated comments from being generated every time a file is rearranged. This also allows you to make minor changes to your fixed comments and have the Rearranger locate and remove the old ones. <p>&nbsp;</p><ul><li>&quot;Generate Pattern&quot; creates a regular expression that will match all user-specified comments, including comment rules and extracted method comments. </li><li>&quot;Verify Comments Against Pattern&quot; checks to see that all your fixed comments match the pattern supplied. A dialog box will display any that do not. </li></ul><p>TIP: all comments specified in separator comment rules are automatically removed from the file before rearranging. The global comment pattern is really only useful if you need to remove old comments of a different style. Suppose you are changing from dashes to periods ( <strong>// --- comment ---</strong> becomes <strong>// ... comment ...</strong> ). Then specifying a global comment pattern of <strong>// -+ [a-zA-Z0-9] -+</strong> would remove all the old comments. In addition, any blank lines adjacent to these old comments will be stripped. (It is probably easier just to use the Edit...Replace feature with a regular expression.) </p><p><a name="SpacingAnchor"></a></p><h3><a name="Spacing_Options"></a>Spacing Options </h3><br /><img width="772" height="477" alt="RearrangerSpacing.png" src="https://www.dev.java.net/files/documents/10436/147375/RearrangerSpacing.png" border="0" /> <p>The number of blank lines at certain locations may be forced. These locations are: </p><ul><li>After class opening brace </li><li>Before class closing brace </li><li>After class closing brace </li><li>Before method opening brace </li><li>After method opening brace </li><li>Before method closing brace </li><li>After method closing brace </li></ul>In addition, an option to remove any leading or trailing blank lines within a code block is provided. <p>Precedence is in the order just given, top to bottom. Therefore, if you force no blank lines after a method closing brace but force 2 blank lines before a class closing brace, then there will be 2 blank lines between the last method of a class and its closing brace. </p><p>All blank lines will be stripped from the end of a file; this overrides the &quot;After class closing brace&quot; setting, which could leave blank lines after the last outer class in the file. </p><p><a name="ConfigurationControlAnchor"></a></p><h3><a name="Saving_Restoring_or_Loading_Defa"></a>Saving, Restoring, or Loading Default Configurations </h3><br /><img width="1131" height="594" alt="rearranger44config.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147365/rearranger44config.PNG" border="0" /> <p>&nbsp;</p><p>This dialog permits the user to: </p><ul><li>Clear the configuration; all rules are discarded and default settings installed. </li><li>Load the default configuration. This is stored as a resource (<span style="background: #ffffce"><font color="#0000ff">DefaultConfiguration</font></span><a href="http://web.archive.org/web/20071003161056/http://www.intellij.org/twiki/bin/edit/Main/DefaultConfiguration?topicparent=Main.RearrangerPlugin">?</a>.xml) in the plugin's .jar file. </li><li>Read configuration from a file. </li><li>Write configuration to a file. </li></ul><p><a name="LiveRearranger"></a></p><h3><a name="Performing_Live_Manual_Rearrange"></a>Performing Live (Manual) Rearrangement </h3>The plugin supports a manual mode for rearrangement, in which a popup dialog is displayed showing all the items (classes, fields, methods, etc.) in the file. The user can drag and drop items in the dialog to the desired order. <br /><img width="508" height="332" alt="Rearranger26live.PNG" src="https://rearranger.dev.java.net/files/documents/10436/147373/Rearranger26live.png" border="0" /> <p>&nbsp;</p><p>The live rearrangement function can be invoked by the Edit...Live Rearranger menu item or with the default keystroke Ctrl-comma. Any keystroke or mouse click outside the popup window will dismiss the popup. <a name="OperationAnchor"></a></p><h2><a name="Plugin_Operation"></a>Plugin Operation </h2>First, the plugin parses the file, creating a tree of classes and their contents. <p>Next, the plugin takes each rule in order of highest priority, and (within priority) sequence order. It creates a list of items matching each rule. Items in this list are either in order encountered, or alphabetized if indicated in the rule. </p><p>If configuration indicates that extracted methods should be grouped with their callers, and if the rule does not override the global option, these methods also will be moved. </p><p>If <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#ConfirmAnchor">&quot;Confirm before rearranging&quot;</a> is checked, a dialog is displayed showing the proposed rearrangement. </p><p>If the proposed rearrangement is accepted, the plugin generates a new file, emitting items in sequence order of the rules they match. The plugin conditionally generates comments as it encounters these in the rule list, as described <a href="https://rearranger.dev.java.net/alm-process/1-Documentation/#SeparatorCommentAnchor">above</a>. </p><p>Anything that does not match a rule will appear at the end of the Java file (if ordering classes) or end of the class definition (if ordering class members). For example, creating a class member order list of only &quot;public static void fields&quot; will move all of those to the front of the class; anything that might have been before or between these fields will appear immediately after them. </p><h2><a name="Plugins_installation"></a>Plugin installation </h2><p>Use IDEA's Plugin Manager to install the Rearranger plugin. &nbsp;Installing any plug-in with IDEA, including the Rearranger, is a snap.&nbsp; You don't have to download or build anything. In IDEA, click File | Settings | IDE Setting | Plug-ins.&nbsp; You can then view the plug-ins installed already and what is available. &nbsp;Right click &quot;Rearranger&quot;, and select install. </p>